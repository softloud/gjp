---
title: "forecasts"
author: "Charles T. Gray"
date: "16/09/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[source](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/BPCDH5)

```{r message = FALSE}
library(tidyverse)

# wtf with the file paths?

# for knitting
# raw_dat <-
#     list.files("../") %>%
#         str_subset("fcast") %>%
#         paste0("../", .) %>%
#         map(read_csv)

# for running chunk-wise
raw_dat <- list.files("data-raw") %>%
    str_subset("fcast") %>%
    paste0("data-raw/", .) %>%
    map(read_csv)



```

```{r}
library(gjp)


# bind together
all_forecasts <- raw_dat %>% 
        map(select, -team) %>% 
        bind_rows() %>% 
    dplyr::filter(q_status == "closed") %>%  # only closed questions
    mutate(raw_dat_obs = row_number())


```

```{r}

# we need to get q_type from the ifps csv.
forecasts_binary <- 
    questions %>% 
    select(ifp_id, q_text, q_type, outcome, options, n_opts) %>% # here's where we can add stuff from ifps.csv
    right_join(all_forecasts) # %>% 
    # dplyr::filter(q_type == 0) # binary questions only

    


```


```{r eval=FALSE}

# get first and last timepoints for each user & question
forecasts_all_times <- 
    forecasts_binary %>% 
    group_by(ifp_id, user_id) %>% 
    summarise(
        min_date_time = min(timestamp),
        max_date_time = max(timestamp),
        min_eq_max = min_date_time == max_date_time
    )




```


```{r eval=FALSE}
 
# now to get the forecasts with more than one timepoint

forecasts_mtp <- 
    forecasts_all_times %>% 
    dplyr::filter(!min_eq_max) %>% 
    gather(key = "time_terminal",
           value = "timestamp",
           min_date_time, max_date_time) %>% 
    left_join(forecasts_binary, by = c("ifp_id", "user_id", "timestamp")) %>% 
    ungroup() 

# for one time point
forecasts_otp <-
    forecasts_all_times %>% 
    dplyr::filter(min_eq_max) %>% 
    mutate(time_terminal = "single_entry",
           timestamp = max_date_time
           ) %>% 
    select(-min_date_time, -max_date_time) %>% 
    left_join(forecasts_binary, by = c("ifp_id", "user_id", "timestamp")) %>% 
    ungroup()

forecasts_no_opt_flag <- bind_rows(forecasts_otp, forecasts_mtp)

```

```{r}
# create flag for conditional or not conditional questions 
forecasts <- forecasts_binary %>% 
    # dplyr::filter(fcast_type == 0 | fcast_type == 4) %>% 
    # select(outcome, options) %>% 
    mutate(options_yn = str_detect(options, "Yes") &
               str_detect(options, ("No"))) %>% 
    dplyr::filter( # final filters
        # options_yn == TRUE
        n_opts == 2
        ) %>% 
    mutate(q_conditional = # conditional question indicator, begins with if
               as.numeric(str_detect(options, "If")))  

forecasts$q_conditional %>% table()
forecasts$n_opts %>% summary()
forecasts$fcast_type %>% table()

forecasts %>% pluck("fcast_type") %>% table()

```




```{r eval=FALSE}
usethis::use_data(forecasts, overwrite = TRUE)

```



